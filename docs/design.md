# Design

Hipster should be as composible as possible, allowing for the creation of high level abstractions when working with MIPS assembly code.

It should be possible, for instance, to create loops and functions within the DSL, and program in a style similar to C. Higher level abstractions than that should also be possible. Our goal is for it be easy to

- Create new abstractions
- Utilize existing abstractions
- Document and structure the MIPS output appropriately

The primary goal of Hipster is to provide the programmer with assembly level control, but give them the power to easily write and use higher level abstractions.

# Assembly Programming

Hipster programs can be nearly identical to MIPS assembly programs.

# Syscalls

## SPIM

https://en.wikipedia.org/wiki/SPIM#The_SPIM_operating_system

# Basic Blocks

A basic block in Hipster is constructed with the `MipsBlock` monad, which builds a list of instructions. We should probably use types to ensure that these actually do form basic blocks (no jumps or branches in the middle), much like what Hoopl does.

# Registers

In order to achieve composable abstractions Hipster will perform register allocation for you. However, it is also possible to ask for specific registers instead, which gives you all of the advantages of assembly languge.

# Commenting

Hipster allows you to inject comments. These comments will appear in the output, and can either appear between lines, or at the end of lines.

# Labels

Labels may be automatically generated by Hipster. Normally these labels are simply numbered, but it should also be possible to specify a prefix to these labels. The numbering for each prefix should be done individually. This is to make it easier to read the resulting code. If I have a single label whose prefix is used twice it should not have a suffix like `23`, as that can be confusing.

Hipster will not allow you to manually define labels with numerical suffixes, since this would cause an overlap. These are all considered to be reserved.

# TODO

- Web and console interface for debugging
- Recording and playback of machine state
- MIPS parser to allow for conversion to Hipster, and debugging of ordinary MIPS code
- Code analysis using Hoopl
  - Calling convention assertions? https://en.wikipedia.org/wiki/MIPS_instruction_set#Compiler_register_usage
- Optimization passes (for instance unrolling loop structures nicely)
- Convert to LLVM for native compilation?
- Provide a library of pre-existing utilities for writing MIPS code (loops and such).

# Notes

## Why are we not using LinearScan.Hoopl.DSL?

This is a wonderful library by John Wiegley, and this module does almost exactly what we want (in fact a good chunk of the code that I have written at this point seems to be reinventing the wheel). However, I think we want to:

- Handle labels differently. Stuff as many compile time guarantees as we can in there.
  - This module simply performs string look ups for labels at run time. If the label with the same name already exists the label will be reused.
  - The behaviour we want is slightly different. In order to be able to make composable abstractions we intend to have new labels be generated if the same name is used multiple times (similar to `newVar`). So, our use case is slightly different here.
  - Binding the label to a variable may be desirable as well. By doing this we can ensure that the labels we use exist at Haskell compile time.
  - Might be able to talk to John Wiegley about allowing the user to replace [getLabel](https://github.com/jwiegley/linearscan-hoopl/blob/master/LinearScan/Hoopl/DSL.hs#L58)
